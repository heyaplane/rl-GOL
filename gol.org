#+title: GOL OMSCS

* Goal: Write a GOL program for Simulation & DL projects

* Should meet the following requirements:
1. Uses raylib as graphics/input API
2. Needs to accept prestructured input to define initial state
3. Needs to be able to report arbitrary statistics about a particular run and write to a file
4. Should be able to batch runs from the command line
5. Should be able to run without rendering
6. Ideally written in Odin. May start with C to get things working, then rewrite later.

* Implementation

** Get example running: [[file:~/raylib/examples/others/rlgl_compute_shader.c][Compute shader example]]
- in raylib/example folder, run:
  #+begin_src shell
make clean
make others
cd others
./rlgl_compute_shader
  #+end_src

** Get empty window in different directory

Create a new folder and .c file. Add code.
Compile with:
#+begin_src shell
gcc <name>.c -o <name> -lraylib -lm
#+end_src

** Understand example compute shader program
*** Init
:LOGBOOK:
CLOCK: [2024-10-16 Wed 16:56]--[2024-10-16 Wed 17:35] =>  0:39
CLOCK: [2024-10-16 Wed 13:50]--[2024-10-16 Wed 15:56] =>  2:06
:END:

Comment:
This defines the width of the compute shader "grid".
A similar constant is defined in the [[file:~/raylib/examples/others/resources/shaders/glsl430/gol.glsl][compute shader logic]].

#+begin_src c
  // IMPORTANT: This must match gol*.glsl GOL_WIDTH constant.
// This must be a multiple of 16 (check golLogic compute dispatch).
#define GOL_WIDTH 768
#+end_src

From [[file:/home/egret/raylib/examples/others/rlgl_compute_shader.c::24][rlgl_compute_shader.c]]

Comment:
Initializes the RL Window.

#+begin_src c
      InitWindow(GOL_WIDTH, GOL_WIDTH, "raylib [rlgl] example - compute shader - game of life");
#+end_src

From ~main~ (in [[file:/home/egret/raylib/examples/others/rlgl_compute_shader.c::52][rlgl_compute_shader.c]])

Comment:
This variable sets the resolution uniform variable in the shader, but only as a parameter calling GetShaderLocation & SetShaderValue.

#+begin_src c
      const Vector2 resolution = { GOL_WIDTH, GOL_WIDTH };
#+end_src

From ~main~ (in [[file:/home/egret/raylib/examples/others/rlgl_compute_shader.c::54][rlgl_compute_shader.c]])

Comment:
Shader init code. Apparently the compute shader cannot be loaded directly, only from text (?)

#+begin_src c
      // Game of Life logic compute shader
    char *golLogicCode = LoadFileText("resources/shaders/glsl430/gol.glsl");
    unsigned int golLogicShader = rlCompileShader(golLogicCode, RL_COMPUTE_SHADER);
    unsigned int golLogicProgram = rlLoadComputeShaderProgram(golLogicShader);
    UnloadFileText(golLogicCode);

    // Game of Life logic render shader
    Shader golRenderShader = LoadShader(NULL, "resources/shaders/glsl430/gol_render.glsl");
    int resUniformLoc = GetShaderLocation(golRenderShader, "resolution");

    // Game of Life transfert shader (CPU<->GPU download and upload)
    char *golTransfertCode = LoadFileText("resources/shaders/glsl430/gol_transfert.glsl");
    unsigned int golTransfertShader = rlCompileShader(golTransfertCode, RL_COMPUTE_SHADER);
    unsigned int golTransfertProgram = rlLoadComputeShaderProgram(golTransfertShader);
    UnloadFileText(golTransfertCode);
#+end_src

From ~main~ (in [[file:/home/egret/raylib/examples/others/rlgl_compute_shader.c::57][rlgl_compute_shader.c]])

Comment:
This code creates the compute buffers. RL_DYNAMIC_COPY tells the GPU that this data will be modified repeatedly, allowing for the appropriate memory optimizations.

#+begin_src c
      // Load shader storage buffer object (SSBO), id returned
    unsigned int ssboA = rlLoadShaderBuffer(GOL_WIDTH*GOL_WIDTH*sizeof(unsigned int), NULL, RL_DYNAMIC_COPY);
    unsigned int ssboB = rlLoadShaderBuffer(GOL_WIDTH*GOL_WIDTH*sizeof(unsigned int), NULL, RL_DYNAMIC_COPY);
    unsigned int ssboTransfert = rlLoadShaderBuffer(sizeof(GolUpdateSSBO), NULL, RL_DYNAMIC_COPY);
#+end_src

From ~main~ (in [[file:/home/egret/raylib/examples/others/rlgl_compute_shader.c::73][rlgl_compute_shader.c]])

*** DONE Figure out how to load arbitrary data into compute buffer
CLOSED: [2024-10-18 Fri 10:53]

Comment:
Texture used in rendering shader

#+begin_src c
    Image whiteImage = GenImageColor(GOL_WIDTH, GOL_WIDTH, WHITE);
    Texture whiteTex = LoadTextureFromImage(whiteImage);
#+end_src

#+begin_src c
    BeginShaderMode(golRenderShader);
    DrawTexture(whiteTex, 0, 0, WHITE);
    EndShaderMode();
#+end_src

From ~main~ (in [[file:/home/egret/raylib/examples/others/rlgl_compute_shader.c::85][rlgl_compute_shader.c]])

*** Game Loop

Comment:
This is where the compute shader is dispatched.
Before that can happen, the buffers must be bound to their "slots" in memory. Any shader can access these binding points, so they can be called outside of any EnableShader/DisableShader block.

#+begin_src c
              // Process game of life logic
            rlEnableShader(golLogicProgram);
            rlBindShaderBuffer(ssboA, 1);
            rlBindShaderBuffer(ssboB, 2);
            rlComputeShaderDispatch(GOL_WIDTH/16, GOL_WIDTH/16, 1);
            rlDisableShader();

            // ssboA <-> ssboB
            int temp = ssboA;
            ssboA = ssboB;
            ssboB = temp;
#+end_src

From ~main~ (in [[file:/home/egret/raylib/examples/others/rlgl_compute_shader.c::124][rlgl_compute_shader.c]])

Comment:
For example, here:

#+begin_src c
          rlBindShaderBuffer(ssboA, 1);
#+end_src

From ~main~ (in [[file:/home/egret/raylib/examples/others/rlgl_compute_shader.c::137][rlgl_compute_shader.c]])

Comment:
Finally, we draw the output. The only critical bits are the first 4 lines.

#+begin_src c
          BeginDrawing();

            ClearBackground(BLANK);

            BeginShaderMode(golRenderShader);
                DrawTexture(whiteTex, 0, 0, WHITE);
            EndShaderMode();

            DrawRectangleLines(GetMouseX() - brushSize/2, GetMouseY() - brushSize/2, brushSize, brushSize, RED);

            DrawText("Use Mouse wheel to increase/decrease brush size", 10, 10, 20, WHITE);
            DrawFPS(GetScreenWidth() - 100, 10);

        EndDrawing();
#+end_src

From ~main~ (in [[file:/home/egret/raylib/examples/others/rlgl_compute_shader.c::143][rlgl_compute_shader.c]])

*** Cleanup
:LOGBOOK:
CLOCK: [2024-10-16 Wed 17:35]--[2024-10-16 Wed 17:36] =>  0:01
:END:

Comment:
Unload shaders, buffers, and textures.

#+begin_src c
      // Unload shader buffers objects.
    rlUnloadShaderBuffer(ssboA);
    rlUnloadShaderBuffer(ssboB);
    rlUnloadShaderBuffer(ssboTransfert);

    // Unload compute shader programs
    rlUnloadShaderProgram(golTransfertProgram);
    rlUnloadShaderProgram(golLogicProgram);

    UnloadTexture(whiteTex);            // Unload white texture
    UnloadShader(golRenderShader);      // Unload rendering fragment shader

    CloseWindow();                      // Close window and OpenGL context
#+end_src

From ~main~ (in [[file:/home/egret/raylib/examples/others/rlgl_compute_shader.c::162][rlgl_compute_shader.c]])
** Write own stripped implementation (w/o additional features) and test
:LOGBOOK:
CLOCK: [2024-10-16 Wed 22:22]--[2024-10-16 Wed 22:29] =>  0:07
CLOCK: [2024-10-16 Wed 20:05]--[2024-10-16 Wed 22:11] =>  2:06
:END:

Mostly identical to raylib example.

Comment:
This code generates a random initial state and loads it into the A buffer before starting the game loop.

#+begin_src c
      unsigned int initialState[GOL_WIDTH * GOL_WIDTH];
    for (int i = 0; i < GOL_WIDTH * GOL_WIDTH; i++)
    {
        initialState[i] = GetRandomValue(0, 1);
    }

    rlUpdateShaderBuffer(ssboA, initialState, GOL_WIDTH * GOL_WIDTH * sizeof(unsigned int), 0);
#+end_src

From ~main~ (in [[file:/home/egret/projects/omscs/GOL/gol.c::25][gol.c]])

Comment:
Refactored the code to accept individual width/height. I found that the simulation could support 1600x1440 resolution (~2M cells). Anything significantly larger resulted in a seg fault, likely due to GPU running out of cache.

#+begin_src c
#define GOL_WIDTH 1200
#define GOL_HEIGHT 720
#+end_src

From ~GOL_NUM_GRP_X~ (in [[file:/home/egret/projects/omscs/GOL/gol.c::5][gol.c]])

Comment:
Also added this scale factor, which allows the display resolution to be different from the simulation resolution. For instance, a SCALE_FACTOR of 2 means that each cell takes up 4 pixels instead of 1.
This means that the InitWindow() function needs this scale factor, and a different function is required for sending the texture to the shader.
Or, possibly, I just need to incorporate the scale factor when creating the image. Is there a more efficient way to render the texture than creating a giant texture?

#+begin_src c
#define SCALE_FACTOR 2

Image whiteImg = GenImageColor(GOL_WIDTH, GOL_HEIGHT, WHITE);

DrawTextureEx(whiteTex, (Vector2){0, 0}, 0.0, (float)SCALE_FACTOR, WHITE);
#+end_src

From [[file:/home/egret/projects/omscs/GOL/gol.c::10][gol.c]]

** Allow simulation to accept command line arguments
*** DONE Size of window, scale factor, max number of cycles, number of repeats.
CLOSED: [2024-10-17 Thu 15:06]
:LOGBOOK:
CLOCK: [2024-10-17 Thu 14:21]--[2024-10-17 Thu 15:06] =>  0:45
CLOCK: [2024-10-17 Thu 14:06]--[2024-10-17 Thu 14:20] =>  0:14
:END:

Refactor compile-time constants, pass in grid size to shaders as uniforms.

Comment:
Processing the cmd line args and refactoring variables.
Notice the default values.

#+begin_src c
      int gol_width = 800;
    int gol_height = 400;
    int scale_factor = 1;

    if (argc > 1) gol_width = atoi(argv[1]);
    if (argc > 2) gol_height = atoi(argv[2]);
    if (argc > 3) scale_factor = atoi(argv[3]);

    if (gol_width <= 0 || gol_width % 16 > 0 || gol_height <=0 || gol_height % 16 > 0 || scale_factor < 1)
    {
        printf("Bad command line args.");
        return -1;
    }

    int gol_num_grp_x = gol_width / 16;
    int gol_num_grp_y = gol_height / 16;
#+end_src

From ~main~ (in [[file:/home/egret/projects/omscs/GOL/gol.c::10][gol.c]])

Comment:
Sending uniform values to compute shader is slightly different than fragment shaders. Notice that the shader has to be enabled & disabled.
Also used individual uint variables for width and height to avoid casting in compute shader.

#+begin_src c
      int wVar = rlGetLocationUniform(computeProgram, "gol_width");
    int hVar = rlGetLocationUniform(computeProgram, "gol_height");
    rlEnableShader(computeProgram);
    rlSetUniform(wVar, &gol_width, RL_SHADER_UNIFORM_UINT, 1);
    rlSetUniform(hVar, &gol_height, RL_SHADER_UNIFORM_UINT, 1);
    rlDisableShader();
#+end_src

From ~main~ (in [[file:/home/egret/projects/omscs/GOL/gol.c::34][gol.c]])

Comment:
This prevents the frame time from being written to console every frame.

#+begin_src c
      SetTraceLogLevel(LOG_WARNING);
#+end_src

From ~main~ (in [[file:/home/egret/projects/omscs/GOL/gol.c::8][gol.c]])

*** DONE Plus minimal UI displaying repeat no.
CLOSED: [2024-10-17 Thu 15:19]
:LOGBOOK:
CLOCK: [2024-10-17 Thu 15:11]--[2024-10-17 Thu 15:19] =>  0:08
CLOCK: [2024-10-17 Thu 15:08]--[2024-10-17 Thu 15:09] =>  0:01
:END:

Comment:
This is the code that draws the frame count, which is manually incremented.

#+begin_src c
DrawText(TextFormat("Count: %d", frameCount), GetScreenWidth() - 150, 30, 20, GREEN);
#+end_src

From ~main~ (in [[file:/home/egret/projects/omscs/GOL/gol.c::91][gol.c]])

** Allow simulation to detect repeating/periodic frames

*** DONE Add extra buffers to hold previous data
CLOSED: [2024-10-17 Thu 18:33]
:LOGBOOK:
CLOCK: [2024-10-17 Thu 16:20]--[2024-10-17 Thu 18:33] =>  2:13
:END:

Will restrict possible size of simulation

Comment:
Added extra buffers to hold 1 frame of history + a diff counter to compare next & previous and next & P1 frames.

#+begin_src c
      unsigned int ssboP1 = rlLoadShaderBuffer(gol_width * gol_height * sizeof(unsigned int), NULL, RL_DYNAMIC_COPY);
    unsigned int diffs = rlLoadShaderBuffer(2 * sizeof(unsigned int), NULL, RL_DYNAMIC_COPY);
#+end_src

Also added this gameOver check. The BeginDrawing/EndDrawing is needed because this is where Raylib checks the event buffer for exit signals.
#+begin_src c
        if (gameOver)
        {
            BeginDrawing();
            EndDrawing();
            continue;
        }
.
.
.
        if (calcDiff[0] == 0)
            gameOver = 1;

        else if (calcDiff[1] == 0)
            gameOver = 2;
.
.
.
            if (gameOver)
            {
                sprintf(gameOverText, "Every %d Frames Repeated!", gameOver);
                DrawText(gameOverText, GetScreenWidth() / 4, GetScreenHeight() / 2, 20, RED);
            }
#+end_src

From ~main~ (in [[file:/home/egret/projects/omscs/GOL/gol.c::48][gol.c]])

Comment:
Here is where we count how many cells are different between frames.
The last check actually doesn't work. I think the diffs needs to be explicitly declared as shared memory.

#+begin_src glsl
      if (golBufferDest[index] != golBuffer[index] && diffs[0] == 0)
        atomicAdd(diffs[0], 1);

    if (golBufferDest[index] != golBufferP1[index] && diffs[1] == 0)
        atomicAdd(diffs[1], 1);
#+end_src

From ~main~ (in [[file:/home/egret/projects/omscs/GOL/shaders/gol.glsl::49][gol.glsl]])


NOTE: Adding a 2nd buffer does not help with period = 3 patterns, because it would assume that ONLY period 3 patterns are present (which is probably not true). What's more likely is that you have 1 period 3 pattern and a bunch of period 2 patterns, leading to a situation where the full period is 6!

Fortunately, when this happens, the diff counter starts repeating with a period 3. We can add this check without having to have 6 buffers!
Actually, we can also do this to check for period 2, and lose the P1 buffer altogether. We then just need to check for when the diff count starts to have a period of 2.

*** DONE Implement period checker for diff count instead of holding history buffers
CLOSED: [2024-10-18 Fri 14:54]
:LOGBOOK:
CLOCK: [2024-10-18 Fri 14:53]--[2024-10-18 Fri 14:54] =>  0:01
CLOCK: [2024-10-18 Fri 13:32]--[2024-10-18 Fri 13:35] =>  0:03
CLOCK: [2024-10-18 Fri 11:04]--[2024-10-18 Fri 11:05] =>  0:01
:END:

For now, I will keep the 2nd buffer because I don't think the oscillatory behavior with just the first diff is robust enough.
Actually, I was basing my judgement on the output of the diff calculations every 50 frames, not every frame.
The first diff signal is still not perfectly consistent, but it is probably good enough to just get rid of the P1 buffer.

Not entirely. It's surprisingly common for the 1st diff to repeat, and it is not even consistent for detecting periodicity 2.

Comment:
This is the code that checks for periodicity. Could be refactored to make it cleaner...

#+begin_src c
          if (calcDiff[0] == 0)
            gameOver = 1;

        else if (calcDiff[1] == 0)
                gameOver = 2;

        uint idx = frameCount % 20;
        uint idx_1 = (frameCount - 1) % 20;
        uint idx_2 = (frameCount - 2) % 20;
        uint idx_3 = (frameCount - 3) % 20;
        uint idx_4 = (frameCount - 4) % 20;
        uint idx_5 = (frameCount - 5) % 20;
        uint idx_6 = (frameCount - 6) % 20;
        uint idx_7 = (frameCount - 7) % 20;
        uint idx_8 = (frameCount - 8) % 20;

        diff_history[idx] = calcDiff[1];

        if (diff_history[idx] == diff_history[idx_3])
        {
            if (diff_history[idx_1] == diff_history[idx_4] && diff_history[idx_2] == diff_history[idx_5])
                gameOver = 6;
        }

        if (diff_history[idx] == diff_history[idx_6])
        {
            if (diff_history[idx_1] == diff_history[idx_7] && diff_history[idx_2] == diff_history[idx_8])
                gameOver = 9;
        }
#+end_src

From ~main~ (in [[file:/home/egret/projects/omscs/GOL/gol.c::98][gol.c]])
** Read frame count when specific pixel is turned on
:LOGBOOK:
CLOCK: [2024-11-18 Mon 10:50]--[2024-11-18 Mon 11:17] =>  0:27
:END:
*** Make flag compute shader and set when cell turns on


** KILLED Add restart button
CLOSED: [2024-11-23 Sat 10:30]
** KILLED Add ability to batch runs and automatically restart
CLOSED: [2024-11-23 Sat 10:30]

Should output number of cycles, type of periodicity and seed number for reproducability

** KILLED Add ability to set random seed
CLOSED: [2024-11-23 Sat 10:30]
:PROPERTIES:
:ID:       90f412a9-45d9-43fd-9e63-0a0300c0a26f
:END:
** KILLED Add max cycle count
CLOSED: [2024-11-23 Sat 10:30]
** KILLED Cross-compile to Windows
CLOSED: [2024-11-23 Sat 10:30]

Might want to use zig cc.

** TODO Translate frame count markers to 0s and 1s
** TODO Write code to generate PRNs according to different spacings and bits and write to .csv file
** TODO Analyze PRNs in excel
